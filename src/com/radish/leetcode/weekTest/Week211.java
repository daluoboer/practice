package com.radish.leetcode.weekTest;

import java.util.*;

/**
 * @Description Week211
 * @Author Radish
 * @Date 2020-10-18 10:31
 */
public class Week211 {
    public static void main(String[] args) {
        Week211 w = new Week211();

        /*int[][] ints = new int[][]{{4,5},{4,5},{3,2},{2,3},{3,4}};
        int n = 5, threshold = 1;*/
        /*int[][] ints = new int[][]{{4,5},{3,4},{3,2},{2,6},{1,3}};
        int n = 6, threshold = 0;*/
        /*int[][] ints = new int[][]{{1,4},{2,5},{3,6}};
        int n = 6, threshold = 3;*/
        int[][] ints = new int[][]{{8,3},{14,9},{22,23},{22,25},{12,6},{17,3},{25,17},{26,14},{4,12},{16,12},{16,9},{26,3},{20,22},{17,18},{3,16},{20,17},{24,9},{12,26},{1,4},{23,24},{12,8},{6,22},{18,20},{22,13},{11,3},{8,18},{18,15},{16,11},{4,15},{25,3},{1,12},{2,15},{2,1},{5,2},{15,25},{18,10},{16,1},{16,6},{7,22},{26,13},{24,6},{23,4},{9,25},{24,26},{7,17},{6,25},{2,9},{13,9},{1,20},{5,26},{15,14},{5,16},{7,9},{15,19},{16,2},{1,13},{3,7},{9,26},{3,13},{8,23},{7,1},{10,19},{23,9},{16,13},{18,25},{14,2},{16,17},{21,7},{19,4},{6,9},{25,12},{9,5},{1,18},{26,7},{12,21},{12,20},{24,3},{24,19},{5,14},{12,3},{20,2},{7,23},{24,21},{4,5},{8,20},{19,22},{21,5},{26,6},{16,19},{23,25},{18,26},{10,25},{3,5},{14,19},{21,22},{22,1},{4,25},{15,11},{15,24},{10,15},{23,17},{25,11},{23,21},{8,2},{5,22},{19,23},{3,20},{21,2},{5,25},{4,7},{8,21},{1,6},{18,6},{17,13},{26,8},{23,6},{6,11},{6,10},{7,8},{18,5},{20,15},{11,14},{24,1},{16,24},{2,22},{3,22},{25,21},{7,2},{1,11},{19,12},{19,1},{22,8},{10,3},{16,10},{6,15},{26,4},{9,8},{5,20},{4,13},{23,3},{18,21},{10,23},{14,16},{24,25},{13,11},{4,2},{26,2},{3,1},{18,14},{14,6},{6,2},{14,4},{24,11},{1,5},{4,21},{22,17},{17,14},{10,11},{11,26},{6,4},{19,26},{16,20},{18,4},{8,6},{26,25},{10,17},{20,13},{9,20},{16,18},{8,5},{5,6},{21,26},{17,21},{26,16},{5,7},{14,7},{3,9},{23,18},{9,10},{17,26},{15,16},{13,21},{1,21},{17,8},{21,9},{10,8},{24,4},{19,20},{20,7},{1,8},{1,9},{24,20},{18,7},{4,9},{2,17},{22,18},{25,19},{7,6},{23,5},{14,1},{13,24},{5,13},{14,21},{23,26},{6,13},{10,5},{17,1},{24,22},{3,15},{11,5},{22,14},{17,24},{7,25},{24,7},{18,11},{26,1},{11,7},{25,20},{24,8},{19,17},{12,23},{17,12},{12,13},{23,13},{14,24},{16,22},{25,13},{18,24},{20,23},{25,16},{24,5},{10,14},{12,14},{3,14},{11,9},{8,13},{21,16},{12,9},{26,15},{4,11},{5,17},{23,14},{20,10},{11,23},{2,11},{10,7},{4,8},{24,10},{25,8},{8,16},{7,13},{3,18},{2,23},{10,26},{19,11},{12,24},{2,3},{15,9},{11,17},{11,8},{21,19},{14,8},{11,20},{21,10},{12,7},{12,5},{21,15},{11,12},{2,10},{3,6},{17,15},{2,24},{16,23},{13,15},{19,18},{13,10},{4,3},{21,20},{22,9},{10,12},{18,2},{2,12},{6,21},{13,19},{15,1},{15,5},{3,19},{22,10},{17,4},{1,10},{7,15},{6,20},{14,20},{11,21},{18,13},{19,5},{20,26}};
        int n = 26, threshold = 3;
        List<Boolean> booleans = w.areConnected(n, threshold, ints);
        System.out.println(booleans);
        /*Scanner in = new Scanner(System.in);
        while (true) {
            System.out.println("请输入字符串：");
            String s = in.next();
            int i = w.maxLengthBetweenEqualCharacters(s);
            System.out.println("结果为：" + i);
        }*/
        /*Set<Integer> s1 = new HashSet<>();
//        s1.add(1);
        s1.add(2);
        Set<Integer> s2 = new HashSet<>();
        s2.add(1);
        s2.add(3);
        boolean disjoint = Collections.disjoint(s1, s2);
        System.out.println(disjoint);
        System.out.println(Math.sqrt(4));*/
    }
    /**
     * 5543. 两个相同字符之间的最长子字符串 显示英文描述
     * 通过的用户数0
     * 尝试过的用户数0
     * 用户总通过次数0
     * 用户总提交次数0
     * 题目难度Easy
     * 给你一个字符串 s，请你返回 两个相同字符之间的最长子字符串的长度 ，计算长度时不含这两个字符。如果不存在这样的子字符串，返回 -1 。
     *
     * 子字符串 是字符串中的一个连续字符序列。
     *
     *
     *
     * 示例 1：
     *
     * 输入：s = "aa"
     * 输出：0
     * 解释：最优的子字符串是两个 'a' 之间的空子字符串。
     * 示例 2：
     *
     * 输入：s = "abca"
     * 输出：2
     * 解释：最优的子字符串是 "bc" 。
     * 示例 3：
     *
     * 输入：s = "cbzxy"
     * 输出：-1
     * 解释：s 中不存在出现出现两次的字符，所以返回 -1 。
     * 示例 4：
     *
     * 输入：s = "cabbac"
     * 输出：4
     * 解释：最优的子字符串是 "abba" ，其他的非最优解包括 "bb" 和 "" 。
     *
     *
     * 提示：
     *
     * 1 <= s.length <= 300
     * s 只含小写英文字母
     * @param s
     * @return
     */
    public int maxLengthBetweenEqualCharacters(String s) {
        //只包含小写英文字母，那就只需要查26次就行啦，每个字符第一次和最后一次出现的位置之差-1
        int maxLen = -1;
        for (char c = 'a'; c <= 'z'; c++) {
            int first = -1, end = -1;
            first = s.indexOf(c);
            if (first != -1) {
                end = s.lastIndexOf(c);
            }
            maxLen = maxLen > end - first - 1 ? maxLen : end - first - 1;
        }
        return maxLen;
    }


    /**
     * 5544. 执行操作后字典序最小的字符串 显示英文描述
     * 通过的用户数0
     * 尝试过的用户数0
     * 用户总通过次数0
     * 用户总提交次数0
     * 题目难度Medium
     * 给你一个字符串 s 以及两个整数 a 和 b 。其中，字符串 s 的长度为偶数，且仅由数字 0 到 9 组成。
     *
     * 你可以在 s 上按任意顺序多次执行下面两个操作之一：
     *
     * 累加：将  a 加到 s 中所有下标为奇数的元素上（下标从 0 开始）。数字一旦超过 9 就会变成 0，如此循环往复。例如，如果 s = "3456" 且 a = 5，则执行此操作后 s 变成 "3951"。
     * 轮转：将 s 向右轮转 b 位。例如，如果 s = "3456" 且 b = 1，则执行此操作后 s 变成 "6345"。
     * 请你返回在 s 上执行上述操作任意次后可以得到的 字典序最小 的字符串。
     *
     * 如果两个字符串长度相同，那么字符串 a 字典序比字符串 b 小可以这样定义：在 a 和 b 出现不同的第一个位置上，字符串 a 中的字符出现在字母表中的时间早于 b 中的对应字符。例如，"0158” 字典序比 "0190" 小，因为不同的第一个位置是在第三个字符，显然 '5' 出现在 '9' 之前。
     *
     *
     *
     * 示例 1：
     *
     * 输入：s = "5525", a = 9, b = 2
     * 输出："2050"
     * 解释：执行操作如下：
     * 初态："5525"
     * 轮转："2555"
     * 累加："2454"
     * 累加："2353"
     * 轮转："5323"
     * 累加："5222"
     * 累加："5121"
     * 轮转："2151"
     * 累加："2050"​​​​​​​​​​​​
     * 无法获得字典序小于 "2050" 的字符串。
     * 示例 2：
     *
     * 输入：s = "74", a = 5, b = 1
     * 输出："24"
     * 解释：执行操作如下：
     * 初态："74"
     * 轮转："47"
     * 累加："42"
     * 轮转："24"​​​​​​​​​​​​
     * 无法获得字典序小于 "24" 的字符串。
     * 示例 3：
     *
     * 输入：s = "0011", a = 4, b = 2
     * 输出："0011"
     * 解释：无法获得字典序小于 "0011" 的字符串。
     * 示例 4：
     *
     * 输入：s = "43987654", a = 7, b = 3
     * 输出："00553311"
     *
     *
     * 提示：
     *
     * 2 <= s.length <= 100
     * s.length 是偶数
     * s 仅由数字 0 到 9 组成
     * 1 <= a <= 9
     * 1 <= b <= s.length - 1
     * @param s
     * @param a
     * @param b
     * @return
     */
    public String findLexSmallestString(String s, int a, int b) {
        //这咋做啊，不会呀
        return null;
    }

    /**
     * 5545. 无矛盾的最佳球队 显示英文描述
     * 通过的用户数0
     * 尝试过的用户数0
     * 用户总通过次数0
     * 用户总提交次数0
     * 题目难度Medium
     * 假设你是球队的经理。对于即将到来的锦标赛，你想组合一支总体得分最高的球队。球队的得分是球队中所有球员的分数 总和 。
     *
     * 然而，球队中的矛盾会限制球员的发挥，所以必须选出一支 没有矛盾 的球队。如果一名年龄较小球员的分数 严格大于 一名年龄较大的球员，则存在矛盾。同龄球员之间不会发生矛盾。
     *
     * 给你两个列表 scores 和 ages，其中每组 scores[i] 和 ages[i] 表示第 i 名球员的分数和年龄。请你返回 所有可能的无矛盾球队中得分最高那支的分数 。
     *
     *
     *
     * 示例 1：
     *
     * 输入：scores = [1,3,5,10,15], ages = [1,2,3,4,5]
     * 输出：34
     * 解释：你可以选中所有球员。
     * 示例 2：
     *
     * 输入：scores = [4,5,6,5], ages = [2,1,2,1]
     * 输出：16
     * 解释：最佳的选择是后 3 名球员。注意，你可以选中多个同龄球员。
     * 示例 3：
     *
     * 输入：scores = [1,2,3,5], ages = [8,9,10,1]
     * 输出：6
     * 解释：最佳的选择是前 3 名球员。
     *
     *
     * 提示：
     *
     * 1 <= scores.length, ages.length <= 1000
     * scores.length == ages.length
     * 1 <= scores[i] <= 106
     * 1 <= ages[i] <= 1000
     * @param scores
     * @param ages
     * @return
     */
    public int bestTeamScore(int[] scores, int[] ages) {
        //e...这也不会啊，都没有思路，是动态规划吗？？？？
        //感觉像是动态规划、回溯啥的
        return 0;
    }

    /**
     * 5128. 带阈值的图连通性 显示英文描述
     * 通过的用户数0
     * 尝试过的用户数0
     * 用户总通过次数0
     * 用户总提交次数0
     * 题目难度Hard
     * 有 n 座城市，编号从 1 到 n 。编号为 x 和 y 的两座城市直接连通的前提是： x 和 y 的公因数中，至少有一个 严格大于 某个阈值 threshold 。更正式地说，如果存在整数 z ，且满足以下所有条件，则编号 x 和 y 的城市之间有一条道路：
     *
     * x % z == 0
     * y % z == 0
     * z > threshold
     * 给你两个整数 n 和 threshold ，以及一个待查询数组，请你判断每个查询 queries[i] = [ai, bi] 指向的城市 ai 和 bi 是否直接连通（即，它们之间是否存在一条道路）。
     *
     * 返回数组 answer ，其中answer.length == queries.length 。如果第 i 个查询中指向的城市 ai 和 bi 直接连通，则 answer[i] 为 true ；如果不连通，则 answer[i] 为 false 。
     *
     *
     *
     * 示例 1：
     *
     *
     *
     *
     *
     * 输入：n = 6, threshold = 2, queries = [[1,4],[2,5],[3,6]]
     * 输出：[false,false,true]
     * 解释：每个数的因数如下：
     * 1:   1
     * 2:   1, 2
     * 3:   1, 3
     * 4:   1, 2, 4
     * 5:   1, 5
     * 6:   1, 2, 3, 6
     * 所有大于阈值的的因数已经加粗标识，只有城市 3 和 6 共享公约数 3 ，因此结果是：
     * [1,4]   1 与 4 不连通
     * [2,5]   2 与 5 不连通
     * [3,6]   3 与 6 连通，存在道路 3--6
     * 示例 2：
     *
     *
     *
     *
     *
     * 输入：n = 6, threshold = 0, queries = [[4,5],[3,4],[3,2],[2,6],[1,3]]
     * 输出：[true,true,true,true,true]
     * 解释：每个数的因数与上一个例子相同。但是，由于阈值为 0 ，所有的因数都大于阈值。因为所有的数字共享公因数 1 ，所以所有的城市都互相连通。
     * 示例 3：
     *
     *
     *
     *
     *
     * 输入：n = 5, threshold = 1, queries = [[4,5],[4,5],[3,2],[2,3],[3,4]]
     * 输出：[false,false,false,false,false]
     * 解释：只有城市 2 和 4 共享的公约数 2 严格大于阈值 1 ，所以只有这两座城市是连通的。
     * 注意，同一对节点 [x, y] 可以有多个查询，并且查询 [x，y] 等同于查询 [y，x] 。
     *
     *
     * 提示：
     *
     * 2 <= n <= 104
     * 0 <= threshold <= n
     * 1 <= queries.length <= 105
     * queries[i].length == 2
     * 1 <= ai, bi <= cities
     * ai != bi
     * @param n
     * @param threshold
     * @param queries
     * @return
     */
    public List<Boolean> areConnected(int n, int threshold, int[][] queries) {
        List<Boolean> result = new ArrayList<>();
        if (threshold == 0) {
            int length = queries.length;
            while (length > 0) {
                result.add(true);
                length--;
            }
            return result;
        }
        if (threshold > n/2) {
            int length = queries.length;
            while (length > 0) {
                result.add(false);
                length--;
            }
            return result;
        }
        //需要存储成map吗，用到某个数的时候就存起来~
        for (int i = 0; i < queries.length; i++) {
            int[] query = queries[i];
            result.add(getShare(query,threshold));
        }
        return result;
    }
    Map<Integer, HashSet<Integer>> map = new HashMap<>();
    private Boolean getShare(int[] query, int threshold) {
        HashSet<Integer> q0 = get(map, query[0], threshold);
        HashSet<Integer> q1 = get(map, query[1], threshold);
        //Collections.disjoint：有公共的返回false，没有返回true
        return !Collections.disjoint(q0, q1);
    }

    private HashSet<Integer> get(Map<Integer, HashSet<Integer>> map, int curNum, int threshold) {
        HashSet<Integer> set = map.get(curNum);
        if (set == null) {
            set = new HashSet<>();
            //填值
            if (threshold < curNum) {
                int sqrt = (int)Math.sqrt(curNum) + 1;
                for (int i = 1; i <= sqrt; i++) {
                    if (curNum%i == 0) {
                        if (i > threshold) {
                            set.add(i);
                        }
                        if (curNum/i > threshold) {
                            set.add(curNum/i);
                        }
                    }
                }
            }
        }
        return set;
    }
}
